#!/bin/zsh

consumer_key=""
consumer_secret=""
access_token=""
access_token_secret=""

source binutils.zsh
source array.zsh
source sha1.zsh

function _tw_mkpair()
{
	echo -n "$1="
	shift 1
	_tw_urlencode $(echo -n "$*")
}

function _tw_hex()
{
	table=(0 1 2 3 4 5 6 7 8 9 A B C D E F)
	echo -n ${table[$(($1 / 16 + 1))]}${table[$(($1 % 16 + 1))]}
}

function _tw_tobinary()
{
	if [ ${#*} -eq 0 ]; then
		read text
	else
		text=$1
	fi
	i=1
	hexstr=""
	for ((i = 1; i <= $#text; i += 1)); do
		if [ $(($i % 2)) -eq 1 ]; then
			hexstr="$hexstr\\x"
		fi
		hexstr="${hexstr}${text[$i]}"
	done
	eval echo -n -e \'$hexstr\'
}

function _tw_hmac()
{
	# 引数を数値の配列に直す
	eval data=$(_array_toarray $1)
	eval key=$(_array_toarray $2)
	# 鍵が64octet以上ならSha1する
	if [ "${#key}" -gt "64" ]; then
		eval key=$(_array_toarray "$(_sha1_hash "$2" | _tw_tobinary)")
	fi
	# 計算変数を初期化する
	ohash=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	ihash=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	# 鍵をコピー
	for ((n = 1; n <= $#key; n += 1)); do
		ohash[$n]=${key[$n]}
		ihash[$n]=${key[$n]}
	done
	for ((n = 1; n <= 64; n += 1)); do
		ihash[$n]=$((${ihash[$n]} ^ 0x36))
		ohash[$n]=$((${ohash[$n]} ^ 0x5c))
	done

	# 64+データ長の配列を確保
	temp=""
	for ((n = 1; n <= $((64 + $#data)); n += 1)); do
		temp="0 $temp"
	done
	eval m="($temp)"
	# 鍵とデータを結合
	for ((n = 1; n <= 64; n += 1)); do
		m[$n]=${ihash[$n]}
	done
	for ((n=1; n <= $#data; n += 1)); do
		m[$(($n + 64))]=${data[$n]}
	done
	# sha1を計算する
	temp=""
	for ((n = 1; n <= $#m; n += 1)); do
		temp="$temp$(_tw_hex ${m[$n]})"
	done
	eval K=$(_array_toarray "$(_sha1_hash "$(echo -n $temp | _tw_tobinary)" | _tw_tobinary)")
	# ohashを計算
	m=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	for ((n = 1; n <=64; n += 1)); do
		m[$n]=${ohash[$n]}
	done
	for ((n = 1; n <= 20; n += 1)); do
		m[$(($n + 64))]=${K[$n]}
	done
	temp=""
	for ((n = 1; n <= $#m; n += 1)); do
		temp="$temp$(_tw_hex ${m[$n]})"
	done
	_sha1_hash "$(echo -n $temp | _tw_tobinary)"
}

function _tw_urlencode()
{
	eval base=$(_array_toarray $1)
	temp=""
	for ((n = 1; n <= $#base; n += 1)); do
		case ${base[$n]} in
			45|46|95|126|48|49|50|51|52|53|54|55|56|57|65|66|67|68|69|70|71|72|73|74|75|76|77|78|79|80|81|82|83|84|85|86|87|88|89|90|97|98|99|100|101|102|103|104|105|106|107|108|109|110|111|112|113|114|115|116|117|118|119|120|121|122)
				_tw_hex ${base[$n]} | _tw_tobinary
				;;
			*)
				echo -n '%'
				_tw_hex ${base[$n]}
				;;
		esac
	done
}

function _tw_b64()
{
	table="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
	if [ ${#*} -eq 0 ]; then
		read text
	else
		text=$1
	fi
	eval value=$(_array_toarray $text)
	for ((n=1; n<=$#value; n+=1)); do
		case $((($n - 1) % 3)) in
			0)
				p=$((${value[$n]} >> 2))
				echo -n ${table[$((p + 1))]}
				if [ $n -eq $#value ]; then
					p=$(((${value[$n]} & 0x3) << 4))
					echo -n ${table[$((p + 1))]}==
				fi
				;;
			1)
				p=$((((${value[$(($n - 1))]} & 0x3) << 4) | ((${value[$n]} & 0xf0) >> 4)))
				echo -n ${table[$((p + 1))]}
				if [ $n -eq $#value ]; then
					p=$(((${value[$n]} & 0xf) << 2))
					echo -n ${table[$((p + 1))]}=
				fi
				;;
			2)
				p1=$((((${value[$(($n - 1))]} & 0xf) << 2) | ((${value[$n]} & 0xc0) >> 6)))
				p2=$((${value[$n]} & 0x3f))
				echo -n ${table[$((p1 + 1))]}${table[$((p2 + 1))]} 
				;;
		esac
	done
}

function _tw_sign()
{
	key=$(_tw_urlencode $consumer_secret)\&$(_tw_urlencode $access_token_secret)
	data=$1\&$(_tw_urlencode $2)\&
	oldIFS=$IFS
	IFS="
"
	query=""
	for l in $(sort <(echo -n $3)); do
		if [ "$query" != "" ]; then
			query="$query&"
		fi
		query="${query}$(eval _tw_mkpair $(echo -n $l))"
	done
	data="$data$(_tw_urlencode $query)"
	_tw_b64 "$(_tw_hmac $data $key | _tw_tobinary)"
	IFS=$oldIFS
}

function _tw_request()
{
	params="oauth_token $access_token
oauth_consumer_key $consumer_key
oauth_timestamp $(date +%s)
oauth_nonce $(date +%s)
oauth_signature_method HMAC-SHA1
oauth_version 1.0"

	signparams="$params
$3"

	url="$2"

	signature=$(_tw_sign $1 $url $signparams)
	signparams="$params
oauth_signature $signature"
	query=""
	IFS="
"
	for l in $(sort <(echo -n $signparams)); do
		if [ "$query" != "" ]; then
			query="$query,"
		fi
		query="${query}$(eval _tw_mkpair $(echo -n $l))"
	done
	header="Authorization: OAuth $query"
	
	if [ "$1" = "GET" ]; then
		params=""
		for l in $(echo $3); do
			if [ "$params" != "" ]; then
				query="${params}&"
			fi
			params="${params}$(eval _tw_mkpair $(echo -n $l))"
		done
		eval curl -v -H \"$header\" "\"${url}?${params}\"" 2> /dev/null
	else
		params=""
		for l in $(echo $3); do
			params="${params} -d $(eval _tw_mkpair $(echo -n $l))"
		done
		eval curl -v -H \"$header\" $(echo "$params") $url 2> /dev/null
	fi
}

function get()
{
	_tw_request GET "$1" "$2"
}

function post()
{
	_tw_request POST "$1" "$2"
}

if [ "$1" = "" ]; then
	echo Usage: tw message
	exit 1
fi

post "https://api.twitter.com/1.1/statuses/update.json" "status $1"
