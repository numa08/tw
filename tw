#!/bin/zsh

consumer_key=""
consumer_secret=""
access_token=""
access_token_secret=""

SHA1="shasum"

function toarray()
{
	echo -n '('`echo -n "$1" | od -t u1 -A n | tr -d \\n`')'
}

function hex()
{
	table=(0 1 2 3 4 5 6 7 8 9 A B C D E F)
	echo -n ${table[$(($1 / 16 + 1))]}${table[$(($1 % 16 + 1))]}
}

function tobinary()
{
	if [ ${#*} -eq 0 ]; then
		read text
	else
		text=$1
	fi
	i=1
	hexstr=""
	for ((i = 1; i <= $#text; i += 1)); do
		if [ $(($i % 2)) -eq 1 ]; then
			hexstr="$hexstr\\x"
		fi
		hexstr="${hexstr}${text[$i]}"
	done
	eval echo -n -e \'$hexstr\'
}

function hmac()
{
	# 引数を数値の配列に直す
	eval data=`toarray $1`
	eval key=`toarray $2`
	# 鍵が64octet以上ならSha1する
	if [ "${#key}" -gt "64" ]; then
		eval key='('`echo -n "$2" | $SHA1 -b | cut -b 1-40 | tobinary | od -t u1 -A n | tr -d \\n`')'
	fi
	# 計算変数を初期化する
	ohash=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	ihash=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	# 鍵をコピー
	for ((n = 1; n <= $#key; n += 1)); do
		ohash[$n]=${key[$n]}
		ihash[$n]=${key[$n]}
	done
	for ((n = 1; n <= 64; n += 1)); do
		ihash[$n]=$((${ihash[$n]} ^ 0x36))
		ohash[$n]=$((${ohash[$n]} ^ 0x5c))
	done

	# 64+データ長の配列を確保
	temp=""
	for ((n = 1; n <= $((64 + $#data)); n += 1)); do
		temp="0 $temp"
	done
	eval m="($temp)"
	# 鍵とデータを結合
	for ((n = 1; n <= 64; n += 1)); do
		m[$n]=${ihash[$n]}
	done
	for ((n=1; n <= $#data; n += 1)); do
		m[$(($n + 64))]=${data[$n]}
	done
	# sha1を計算する
	temp=""
	for ((n = 1; n <= $#m; n += 1)); do
		temp="$temp`hex ${m[$n]}`"
	done
	eval K='('`echo -n $temp | tobinary | $SHA1 -b | cut -b 1-40 | tobinary | od -t u1 -A n | tr -d \\n`')'
	# ohashを計算
	m=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	for ((n = 1; n <=64; n += 1)); do
		m[$n]=${ohash[$n]}
	done
	for ((n = 1; n <= 20; n += 1)); do
		m[$(($n + 64))]=${K[$n]}
	done
	temp=""
	for ((n = 1; n <= $#m; n += 1)); do
		temp="$temp`hex ${m[$n]}`"
	done
	echo -n $temp | tobinary | $SHA1 -b | cut -b 1-40
}

function urlencode()
{
	eval base=`toarray $1`
	temp=""
	for ((n = 1; n <= $#base; n += 1)); do
		case ${base[$n]} in
			45|46|95|126|48|49|50|51|52|53|54|55|56|57|65|66|67|68|69|70|71|72|73|74|75|76|77|78|79|80|81|82|83|84|85|86|87|88|89|90|97|98|99|100|101|102|103|104|105|106|107|108|109|110|111|112|113|114|115|116|117|118|119|120|121|122)
				hex ${base[$n]} | tobinary
				;;
			*)
				echo -n '%'
				hex ${base[$n]}
				;;
		esac
	done
}

function b64()
{
	table=(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + /)
	if [ ${#*} -eq 0 ]; then
		read text
	else
		text=$1
	fi
	eval value=`toarray $text`
	for ((n=1; n<=$#value; n+=1)); do
		case $((($n - 1) % 3)) in
			0)
				p=$((${value[$n]} >> 2))
				echo -n ${table[$((p + 1))]}
				if [ $n -eq $#value ]; then
					p=$(((${value[$n]} & 0x3) << 4))
					echo -n ${table[$((p + 1))]}==
				fi
				;;
			1)
				p=$((((${value[$(($n - 1))]} & 0x3) << 4) | ((${value[$n]} & 0xf0) >> 4)))
				echo -n ${table[$((p + 1))]}
				if [ $n -eq $#value ]; then
					p=$(((${value[$n]} & 0xf) << 2))
					echo -n ${table[$((p + 1))]}=
				fi
				;;
			2)
				p1=$((((${value[$(($n - 1))]} & 0xf) << 2) | ((${value[$n]} & 0xc0) >> 6)))
				p2=$((${value[$n]} & 0x3f))
				echo -n ${table[$((p1 + 1))]}${table[$((p2 + 1))]} 
				;;
		esac
	done
}

function sign()
{
	key=`urlencode $consumer_secret`\&`urlencode $access_token_secret`
	data=$1\&`urlencode $2`\&
	oldIFS=$IFS
	IFS="
"
	query=""
	for l in `sort <(echo -n $3)`; do
		if [ "$query" != "" ]; then
			query="$query&"
		fi
		query="${query}`echo -n $l | awk '{print $1;}'`=`urlencode \`echo -n $l | awk '{print $2;}'\``"
	done
	data="$data`urlencode $query`"
	hmac $data $key | tobinary | b64
	IFS=$oldIFS
}

function request()
{
	params="oauth_token $access_token
oauth_consumer_key $consumer_key
oauth_timestamp `date +%s`
oauth_nonce `date +%s`
oauth_signature_method HMAC-SHA1
oauth_version 1.0"

	signparams="$params
$3"

	url="$2"

	signature=`sign $1 $url $signparams`
	signparams="$params
oauth_signature $signature"
	query=""
	IFS="
"
	for l in `sort <(echo -n $signparams)`; do
		if [ "$query" != "" ]; then
			query="$query,"
		fi
		query="${query}`echo -n $l | awk '{print $1;}'`=`urlencode \`echo -n $l | awk '{print $2;}'\``"
	done
	header="Authorization: OAuth $query"
	
	if [ "$1" = "GET" ]; then
		params=""
		for l in `echo $3`; do
			if [ "$params" != "" ]; then
				query="${params}&"
			fi
			params="${params}`echo -n $l | awk '{print $1;}'`=`urlencode \`echo -n $l | awk '{print $2;}'\``"
		done
		eval curl -v -H \"$header\" "\"${url}?${params}\"" 2> /dev/null
	else
		params=""
		for l in `echo $3`; do
			params="${params} -d `echo -n $l | awk '{print $1;}'`=`urlencode \`echo -n $l | awk '{print $2;}'\``"
		done
		eval curl -v -H \"$header\" `echo "$params"` $url 2> /dev/null
	fi
}

function get()
{
	request GET "$1" "$2"
}

function post()
{
	request POST "$1" "$2"
}

if [ "$1" = "" ]; then
	echo Usage: tw message
	exit 1
fi

post "https://api.twitter.com/1.1/statuses/update.json" "status $1"
